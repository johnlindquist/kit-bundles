// Generated by dts-bundle-generator v5.9.0

/// <reference types="node" />

declare class Subscriber<T> extends Subscription implements Observer<T> {
	/**
	 * A static factory for a Subscriber, given a (potentially partial) definition
	 * of an Observer.
	 * @param next The `next` callback of an Observer.
	 * @param error The `error` callback of an
	 * Observer.
	 * @param complete The `complete` callback of an
	 * Observer.
	 * @return A Subscriber wrapping the (partially defined)
	 * Observer represented by the given arguments.
	 * @nocollapse
	 * @deprecated Do not use. Will be removed in v8. There is no replacement for this
	 * method, and there is no reason to be creating instances of `Subscriber` directly.
	 * If you have a specific use case, please file an issue.
	 */
	static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T>;
	/** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */
	protected isStopped: boolean;
	/** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */
	protected destination: Subscriber<any> | Observer<any>;
	/**
	 * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
	 * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.
	 */
	constructor(destination?: Subscriber<any> | Observer<any>);
	/**
	 * The {@link Observer} callback to receive notifications of type `next` from
	 * the Observable, with a value. The Observable may call this method 0 or more
	 * times.
	 * @param {T} [value] The `next` value.
	 * @return {void}
	 */
	next(value?: T): void;
	/**
	 * The {@link Observer} callback to receive notifications of type `error` from
	 * the Observable, with an attached `Error`. Notifies the Observer that
	 * the Observable has experienced an error condition.
	 * @param {any} [err] The `error` exception.
	 * @return {void}
	 */
	error(err?: any): void;
	/**
	 * The {@link Observer} callback to receive a valueless notification of type
	 * `complete` from the Observable. Notifies the Observer that the Observable
	 * has finished sending push-based notifications.
	 * @return {void}
	 */
	complete(): void;
	unsubscribe(): void;
	protected _next(value: T): void;
	protected _error(err: any): void;
	protected _complete(): void;
}
declare class Subscription implements SubscriptionLike {
	private initialTeardown?;
	/** @nocollapse */
	static EMPTY: Subscription;
	/**
	 * A flag to indicate whether this Subscription has already been unsubscribed.
	 */
	closed: boolean;
	private _parentage;
	/**
	 * The list of registered teardowns to execute upon unsubscription. Adding and removing from this
	 * list occurs in the {@link #add} and {@link #remove} methods.
	 */
	private _teardowns;
	/**
	 * @param initialTeardown A function executed first as part of the teardown
	 * process that is kicked off when {@link #unsubscribe} is called.
	 */
	constructor(initialTeardown?: (() => void) | undefined);
	/**
	 * Disposes the resources held by the subscription. May, for instance, cancel
	 * an ongoing Observable execution or cancel any other type of work that
	 * started when the Subscription was created.
	 * @return {void}
	 */
	unsubscribe(): void;
	/**
	 * Adds a teardown to this subscription, so that teardown will be unsubscribed/called
	 * when this subscription is unsubscribed. If this subscription is already {@link #closed},
	 * because it has already been unsubscribed, then whatever teardown is passed to it
	 * will automatically be executed (unless the teardown itself is also a closed subscription).
	 *
	 * Closed Subscriptions cannot be added as teardowns to any subscription. Adding a closed
	 * subscription to a any subscription will result in no operation. (A noop).
	 *
	 * Adding a subscription to itself, or adding `null` or `undefined` will not perform any
	 * operation at all. (A noop).
	 *
	 * `Subscription` instances that are added to this instance will automatically remove themselves
	 * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove
	 * will need to be removed manually with {@link #remove}
	 *
	 * @param teardown The teardown logic to add to this subscription.
	 */
	add(teardown: TeardownLogic): void;
	/**
	 * Checks to see if a this subscription already has a particular parent.
	 * This will signal that this subscription has already been added to the parent in question.
	 * @param parent the parent to check for
	 */
	private _hasParent;
	/**
	 * Adds a parent to this subscription so it can be removed from the parent if it
	 * unsubscribes on it's own.
	 *
	 * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.
	 * @param parent The parent subscription to add
	 */
	private _addParent;
	/**
	 * Called on a child when it is removed via {@link #remove}.
	 * @param parent The parent to remove
	 */
	private _removeParent;
	/**
	 * Removes a teardown from this subscription that was previously added with the {@link #add} method.
	 *
	 * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves
	 * from every other `Subscription` they have been added to. This means that using the `remove` method
	 * is not a common thing and should be used thoughtfully.
	 *
	 * If you add the same teardown instance of a function or an unsubscribable object to a `Subcription` instance
	 * more than once, you will need to call `remove` the same number of times to remove all instances.
	 *
	 * All teardown instances are removed to free up memory upon unsubscription.
	 *
	 * @param teardown The teardown to remove from this subscription
	 */
	remove(teardown: Exclude<TeardownLogic, void>): void;
}
declare global {
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
export declare class Observable<T> implements Subscribable<T> {
	/**
	 * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
	 */
	source: Observable<any> | undefined;
	/**
	 * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
	 */
	operator: Operator<any, T> | undefined;
	/**
	 * @constructor
	 * @param {Function} subscribe the function that is called when the Observable is
	 * initially subscribed to. This function is given a Subscriber, to which new values
	 * can be `next`ed, or an `error` method can be called to raise an error, or
	 * `complete` can be called to notify of a successful completion.
	 */
	constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic);
	/**
	 * Creates a new Observable by calling the Observable constructor
	 * @owner Observable
	 * @method create
	 * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	 * @return {Observable} a new observable
	 * @nocollapse
	 * @deprecated Use `new Observable()` instead. Will be removed in v8.
	 */
	static create: (...args: any[]) => any;
	/**
	 * Creates a new Observable, with this Observable instance as the source, and the passed
	 * operator defined as the new observable's operator.
	 * @method lift
	 * @param operator the operator defining the operation to take on the observable
	 * @return a new observable with the Operator applied
	 * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
	 * If you have implemented an operator using `lift`, it is recommended that you create an
	 * operator by simply returning `new Observable()` directly. See "Creating new operators from
	 * scratch" section here: https://rxjs.dev/guide/operators
	 */
	lift<R>(operator?: Operator<T, R>): Observable<R>;
	subscribe(observer?: Partial<Observer<T>>): Subscription;
	subscribe(next: (value: T) => void): Subscription;
	/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */
	subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;
	/**
	 * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with
	 * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.
	 *
	 * **WARNING**: Only use this with observables you *know* will complete. If the source
	 * observable does not complete, you will end up with a promise that is hung up, and
	 * potentially all of the state of an async function hanging out in memory. To avoid
	 * this situation, look into adding something like {@link timeout}, {@link take},
	 * {@link takeWhile}, or {@link takeUntil} amongst others.
	 *
	 * ### Example:
	 *
	 * ```ts
	 * import { interval } from 'rxjs';
	 * import { take } from 'rxjs/operators';
	 *
	 * const source$ = interval(1000).pipe(take(4));
	 *
	 * async function getTotal() {
	 *    let total = 0;
	 *
	 *    await source$.forEach(value => {
	 *      total += value;
	 *      console.log('observable -> ', value);
	 *    });
	 *
	 *    return total;
	 * }
	 *
	 * getTotal().then(
	 *    total => console.log('Total:', total)
	 * )
	 *
	 * // Expected:
	 * // "observable -> 0"
	 * // "observable -> 1"
	 * // "observable -> 2"
	 * // "observable -> 3"
	 * // "Total: 6"
	 * ```
	 * @param next a handler for each value emitted by the observable
	 * @return a promise that either resolves on observable completion or
	 *  rejects with the handled error
	 */
	forEach(next: (value: T) => void): Promise<void>;
	/**
	 * @param next a handler for each value emitted by the observable
	 * @param promiseCtor a constructor function used to instantiate the Promise
	 * @return a promise that either resolves on observable completion or
	 *  rejects with the handled error
	 * @deprecated Passing a Promise constructor will no longer be available
	 * in upcoming versions of RxJS. This is because it adds weight to the library, for very
	 * little benefit. If you need this functionality, it is recommended that you either
	 * polyfill Promise, or you create an adapter to convert the returned native promise
	 * to whatever promise implementation you wanted. Will be removed in v8.
	 */
	forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;
	pipe(): Observable<T>;
	pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;
	pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;
	pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;
	pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>;
	pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>;
	pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>;
	pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>;
	pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>;
	pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>;
	pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>, ...operations: OperatorFunction<any, any>[]): Observable<unknown>;
	/** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */
	toPromise(): Promise<T | undefined>;
	/** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */
	toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;
	/** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */
	toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;
}
/**
 * An Observable that emits no items to the Observer and never completes.
 *
 * ![](never.png)
 *
 * A simple Observable that emits neither values nor errors nor the completion
 * notification. It can be used for testing purposes or for composing with other
 * Observables. Please note that by never emitting a complete notification, this
 * Observable keeps the subscription from being disposed automatically.
 * Subscriptions need to be manually disposed.
 *
 * ##  Example
 * ### Emit the number 7, then never emit anything else (not even complete)
 * ```ts
 * import { NEVER } from 'rxjs';
 * import { startWith } from 'rxjs/operators';
 *
 * function info() {
 *   console.log('Will not be called');
 * }
 * const result = NEVER.pipe(startWith(7));
 * result.subscribe(x => console.log(x), info, info);
 *
 * ```
 *
 * @see {@link Observable}
 * @see {@link index/EMPTY}
 * @see {@link of}
 * @see {@link throwError}
 */
export declare const NEVER: Observable<never>;
/**
 * Emits a notification from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent notification from each burst of emissions.</span>
 *
 * ![](debounceTime.png)
 *
 * `debounceTime` delays notifications emitted by the source Observable, but drops
 * previous pending delayed emissions if a new notification arrives on the source
 * Observable. This operator keeps track of the most recent notification from the
 * source Observable, and emits that only when `dueTime` has passed
 * without any other notification appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous notification will be dropped
 * and will not be emitted and a new `dueTime` is scheduled.
 * If the completing event happens during `dueTime` the last cached notification
 * is emitted before the completion event is forwarded to the output observable.
 * If the error event happens during `dueTime` or after it only the error event is
 * forwarded to the output observable. The cache notification is not emitted in this case.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * notification to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link SchedulerLike} for
 * managing timers.
 *
 * ## Example
 * Emit the most recent click after a burst of clicks
 * ```ts
 * import { fromEvent } from 'rxjs';
 * import { debounceTime } from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(debounceTime(1000));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link audit}
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link debounceTime}
 * @see {@link sample}
 * @see {@link sampleTime}
 * @see {@link throttle}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {SchedulerLike} [scheduler=async] The {@link SchedulerLike} to use for
 * managing the timers that handle the timeout for each value.
 * @return A function that returns an Observable that delays the emissions of
 * the source Observable by the specified `dueTime`, and may drop some values
 * if they occur too frequently.
 */
export declare function debounceTime<T>(dueTime: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;
/**
 * Returns a result {@link Observable} that emits all values pushed by the source observable if they
 * are distinct in comparison to the last value the result observable emitted.
 *
 * 1. It will always emit the first value from the source.
 * 2. The `keySelector` will be run against all values, including the first value.
 * 3. For all values after the first, the selected key will be compared against the key selected from
 *    the previously emitted value using the `comparator`.
 * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted
 *    and the selected key from that value is saved for future comparisons against other keys.
 *
 * ## Example
 *
 * Selecting update events only when the `updatedBy` field shows
 * the account changed hands...
 *
 * ```ts
 * // A stream of updates to a given account
 * const accountUpdates$ = of(
 *   { updatedBy: "blesh", data: [] },
 *   { updatedBy: "blesh", data: [] },
 *   { updatedBy: "ncjamieson", data: [] },
 *   { updatedBy: "ncjamieson", data: [] },
 *   { updatedBy: "blesh", data: [] }
 * );
 *
 * // We only want the events where it changed hands
 * const changedHands$ = accountUpdates$.pipe(
 *   distinctUntilChanged(undefined, update => update.updatedBy)
 * );
 *
 * changedHands$.subscribe(console.log);
 * // Logs:
 * // {updatedBy: "blesh", data: Array[0]}
 * // {updatedBy: "ncjamieson", data: Array[0]}
 * // {updatedBy: "blesh", data: Array[0]}
 * ```
 *
 * @param comparator A function used to compare the previous and current keys for
 * equality. Defaults to a `===` check.
 * @param keySelector Used to select a key value to be passed to the `comparator`.
 * @return A function that returns an Observable that emits items from the
 * source Observable with distinct values.
 */
export declare function distinctUntilChanged<T, K>(comparator: (previous: K, current: K) => boolean, keySelector: (value: T) => K): MonoTypeOperatorFunction<T>;
/**
 * Returns a result {@link Observable} that emits all values pushed by the source observable if they
 * are distinct in comparison to the last value the result observable emitted.
 *
 * 1. It will always emit the first value from the source.
 * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values
 *    using the provided `comparator` or an `===` equality check.
 * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and
 *    becomes the new "previously emitted value" internally.
 *
 * ## Example
 *
 * A very basic example with no `comparator`. Note that `1` is emitted more than once,
 * because it's distinct in comparison to the _previously emitted_ value,
 * not in comparison to _all other emitted values_.
 *
 * ```ts
 * import { of } from 'rxjs';
 * import { distinctUntilChanged } from 'rxjs/operators';
 *
 * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3).pipe(
 *  distinctUntilChanged()
 * )
 * .subscribe(console.log);
 * // Logs: 1, 2, 1, 3
 * ```
 *
 * ## Example
 *
 * With a `comparator`, you can do custom comparisons. Let's say
 * you only want to emit a value when all of its components have
 * changed:
 *
 * ```ts
 * import { of } from 'rxjs';
 * import { distinctUntilChanged } from 'rxjs/operators';
 *
 * const totallyDifferentBuilds$ = of(
 *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },
 *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },
 *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },
 *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },
 *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }
 * ).pipe(
 *   distinctUntilChanged((prev, curr) => {
 *     return (
 *       prev.engineVersion === curr.engineVersion ||
 *       prev.transmissionVersion === curr.transmissionVersion
 *     );
 *   })
 * );
 *
 * totallyDifferentBuilds$.subscribe(console.log);
 *
 * // Logs:
 * // {engineVersion: "1.1.0", transmissionVersion: "1.2.0"}
 * // {engineVersion: "1.3.0", transmissionVersion: "1.4.0"}
 * // {engineVersion: "2.0.0", transmissionVersion: "1.5.0"}
 * ```
 *
 * ## Example
 *
 * You can also provide a custom `comparator` to check that emitted
 * changes are only in one direction. Let's say you only want to get
 * the next record temperature:
 *
 * ```ts
 * import { of } from "rxjs";
 * import { distinctUntilChanged } from "rxjs/operators";
 *
 * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);
 *
 * const recordHighs$ = temps$.pipe(
 *   distinctUntilChanged((prevHigh, temp) => {
 *     // If the current temp is less than
 *     // or the same as the previous record,
 *     // the record hasn't changed.
 *     return temp <= prevHigh;
 *   })
 * );
 *
 * recordHighs$.subscribe(console.log);
 * // Logs: 30, 31, 34, 35
 * ```
 *
 * @param comparator A function used to compare the previous and current values for
 * equality. Defaults to a `===` check.
 * @return A function that returns an Observable that emits items from the
 * source Observable with distinct values.
 */
export declare function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;
/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */
export declare function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;
/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */
export declare function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;
export declare function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;
export declare function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;
export declare function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;
/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */
export declare function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;
export declare function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;
export declare function merge<A extends readonly unknown[]>(...sources: [
	...ObservableInputTuple<A>
]): Observable<A[number]>;
export declare function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [
	...ObservableInputTuple<A>,
	number?
]): Observable<A[number]>;
/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */
export declare function merge<A extends readonly unknown[]>(...sourcesAndConcurrencyAndScheduler: [
	...ObservableInputTuple<A>,
	number?,
	SchedulerLike?
]): Observable<A[number]>;
/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */
export declare function merge<A extends readonly unknown[]>(...sourcesAndScheduler: [
	...ObservableInputTuple<A>,
	SchedulerLike?
]): Observable<A[number]>;
export declare function of(): Observable<never>;
/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */
export declare function of(scheduler: SchedulerLike): Observable<never>;
export declare function of(value: null): Observable<null>;
export declare function of(value: undefined): Observable<undefined>;
export declare function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;
/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */
export declare function of<A extends readonly unknown[]>(...valuesAndScheduler: [
	...A,
	SchedulerLike
]): Observable<ValueFromArray<A>>;
/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */
export declare function of<T>(): Observable<T>;
export declare function of<T>(value: T): Observable<T>;
export declare function share<T>(): MonoTypeOperatorFunction<T>;
export declare function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;
export declare function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O): OperatorFunction<T, ObservedValueOf<O>>;
/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */
export declare function switchMap<T, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: undefined): OperatorFunction<T, ObservedValueOf<O>>;
/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */
export declare function switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * ![](take.png)
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * ## Example
 * Take the first 5 seconds of an infinite 1-second interval Observable
 * ```ts
 * import { interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const intervalCount = interval(1000);
 * const takeFive = intervalCount.pipe(take(5));
 * takeFive.subscribe(x => console.log(x));
 *
 * // Logs:
 * // 0
 * // 1
 * // 2
 * // 3
 * // 4
 * ```
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param count The maximum number of `next` values to emit.
 * @return A function that returns an Observable that emits only the first
 * `count` values emitted by the source Observable, or all of the values from
 * the source if the source emits fewer than `count` values.
 */
export declare function take<T>(count: number): MonoTypeOperatorFunction<T>;
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits a value. Then, it completes.</span>
 *
 * ![](takeUntil.png)
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value, the output Observable stops mirroring the source Observable
 * and completes. If the `notifier` doesn't emit any value and completes
 * then `takeUntil` will pass all values.
 *
 * ## Example
 * Tick every second until the first click happens
 * ```ts
 * import { fromEvent, interval } from 'rxjs';
 * import { takeUntil } from 'rxjs/operators';
 *
 * const source = interval(1000);
 * const clicks = fromEvent(document, 'click');
 * const result = source.pipe(takeUntil(clicks));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return A function that returns an Observable that emits the values from the
 * source Observable until `notifier` emits its first value.
 */
export declare function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T>;
export declare function tap<T>(next: (value: T) => void): MonoTypeOperatorFunction<T>;
/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */
export declare function tap<T>(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): MonoTypeOperatorFunction<T>;
export declare function tap<T>(observer?: Partial<TapObserver<T>>): MonoTypeOperatorFunction<T>;
/**
 * A simple type to represent a gamut of "falsy" values... with a notable exception:
 * `NaN` is "falsy" however, it is not and cannot be typed via TypeScript. See
 * comments here: https://github.com/microsoft/TypeScript/issues/28682#issuecomment-707142417
 */
export declare type Falsy = null | undefined | false | 0 | -0 | 0n | "";
/**
 * Valid types that can be converted to observables.
 */
export declare type ObservableInput<T> = Observable<T> | InteropObservable<T> | AsyncIterable<T> | PromiseLike<T> | ArrayLike<T> | Iterable<T> | ReadableStreamLike<T>;
/**
 * Used to infer types from arguments to functions like {@link forkJoin}.
 * So that you can have `forkJoin([Observable<A>, PromiseLike<B>]): Observable<[A, B]>`
 * et al.
 */
export declare type ObservableInputTuple<T> = {
	[K in keyof T]: ObservableInput<T[K]>;
};
/**
 * Extracts the type from an `ObservableInput<any>`. If you have
 * `O extends ObservableInput<any>` and you pass in `Observable<number>`, or
 * `Promise<number>`, etc, it will type as `number`.
 */
export declare type ObservedValueOf<O> = O extends ObservableInput<infer T> ? T : never;
export declare type TeardownLogic = Subscription | Unsubscribable | (() => void) | void;
export declare type TruthyTypesOf<T> = T extends Falsy ? never : T;
/**
 * Extracts the generic value from an Array type.
 * If you have `T extends Array<any>`, and pass a `string[]` to it,
 * `ValueFromArray<T>` will return the actual type of `string`.
 */
export declare type ValueFromArray<A extends readonly unknown[]> = A extends Array<infer T> ? T : never;
/**
 * An object that implements the `Symbol.observable` interface.
 */
export interface InteropObservable<T> {
	[Symbol.observable]: () => Subscribable<T>;
}
export interface MonoTypeOperatorFunction<T> extends OperatorFunction<T, T> {
}
export interface Observer<T> {
	next: (value: T) => void;
	error: (err: any) => void;
	complete: () => void;
}
/***
 * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.
 */
export interface Operator<T, R> {
	call(subscriber: Subscriber<R>, source: any): TeardownLogic;
}
export interface OperatorFunction<T, R> extends UnaryFunction<Observable<T>, Observable<R>> {
}
export interface ReadableStreamDefaultReaderLike<T> {
	read(): PromiseLike<{
		done: false;
		value: T;
	} | {
		done: true;
		value?: undefined;
	}>;
	releaseLock(): void;
}
/**
 * The base signature RxJS will look for to identify and use
 * a [ReadableStream](https://streams.spec.whatwg.org/#rs-class)
 * as an {@link ObservableInput} source.
 */
export interface ReadableStreamLike<T> {
	getReader(): ReadableStreamDefaultReaderLike<T>;
}
export interface SchedulerAction<T> extends Subscription {
	schedule(state?: T, delay?: number): Subscription;
}
/** SCHEDULER INTERFACES */
export interface SchedulerLike extends TimestampProvider {
	schedule<T>(work: (this: SchedulerAction<T>, state: T) => void, delay: number, state: T): Subscription;
	schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number, state?: T): Subscription;
	schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay?: number, state?: T): Subscription;
}
export interface ShareConfig<T> {
	/**
	 * The factory used to create the subject that will connect the source observable to
	 * multicast consumers.
	 */
	connector?: () => SubjectLike<T>;
	/**
	 * If true, the resulting observable will reset internal state on error from source and return to a "cold" state. This
	 * allows the resulting observable to be "retried" in the event of an error.
	 * If false, when an error comes from the source it will push the error into the connecting subject, and the subject
	 * will remain the connecting subject, meaning the resulting observable will not go "cold" again, and subsequent retries
	 * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however
	 * {@link ReplaySubject} will also push its buffered values before pushing the error.
	 * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained
	 * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.
	 */
	resetOnError?: boolean | ((error: any) => Observable<any>);
	/**
	 * If true, the resulting observable will reset internal state on completion from source and return to a "cold" state. This
	 * allows the resulting observable to be "repeated" after it is done.
	 * If false, when the source completes, it will push the completion through the connecting subject, and the subject
	 * will remain the connecting subject, meaning the resulting observable will not go "cold" again, and subsequent repeats
	 * or resubscriptions will resubscribe to that same subject.
	 * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained
	 * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.
	 */
	resetOnComplete?: boolean | (() => Observable<any>);
	/**
	 * If true, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the
	 * internal state will be reset and the resulting observable will return to a "cold" state. This means that the next
	 * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to
	 * again.
	 * If false, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject
	 * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.
	 * It is also possible to pass a notifier factory returning an observable instead which grants more fine-grained
	 * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.
	 */
	resetOnRefCountZero?: boolean | (() => Observable<any>);
}
export interface SubjectLike<T> extends Observer<T>, Subscribable<T> {
}
/** OBSERVABLE INTERFACES */
export interface Subscribable<T> {
	subscribe(observer: Partial<Observer<T>>): Unsubscribable;
}
export interface SubscriptionLike extends Unsubscribable {
	unsubscribe(): void;
	readonly closed: boolean;
}
export interface TapObserver<T> extends Observer<T> {
	subscribe: () => void;
	unsubscribe: () => void;
	finalize: () => void;
}
/**
 * This is a type that provides a method to allow RxJS to create a numeric timestamp
 */
export interface TimestampProvider {
	/**
	 * Returns a timestamp as a number.
	 *
	 * This is used by types like `ReplaySubject` or operators like `timestamp` to calculate
	 * the amount of time passed between events.
	 */
	now(): number;
}
/** OPERATOR INTERFACES */
export interface UnaryFunction<T, R> {
	(source: T): R;
}
/** SUBSCRIPTION INTERFACES */
export interface Unsubscribable {
	unsubscribe(): void;
}

export {};
